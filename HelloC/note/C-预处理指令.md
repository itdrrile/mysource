# C语言 > 预处理指令

> 预编译又叫预处理。预编译不是编译，而是编译前的处理。这个操作是在正式编译之前由系统自动完成的

- 包含命令 `#include`，宏定义命令 `#define`，这些命令都放在函数之外，而且一般都放在源文件的前面，他们称为预处理部分。
- 所谓预处理是指在进行编译的第一遍扫描（词法扫描和语法分析）之前所做的工作。
- 预处理是C语言的一个重要功能，它由预处理程序负责完成。
- 当对一个源文件进行编译时，系统将自动引用预处理程序对源程序中的预处理部分作处理，处理完毕后自动进入对源程序的编译。
- C语言提供了多种预处理功能，如 `宏定义` 、`文件包含` 、`条件编译` 。
- 合理地使用预处理功能编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。



## 1. 无参宏定义#define

在C语言中，“宏”分为 `有参数` 和 `无参数` 两种。

**无参数**的宏名后不带参数。其定义的一般形式为

```c
#define 标识符 字符串
```

"字符串"可以是常数、表达式、格式串等。
例如： `#define M (y*y+3*y)`
他的作用是指定 `标识符M` 来代替表达式 `(y*y+3*y)` 。
在编写源程序时，所有的 `(y*y+3*y)` 都可以由 M 代替。

```c
#define M (y*y+3*y)
main{} {
 int s,y;
 scanf("%d",&y);
 s=3*M+4*M+5*M;  // 预编译处理时，替换为s=3*(y*y+3*y)+4*(y*y+3*y)+5*(y*y+3*y);
 printf("s=%d",s);
}
```

要注意的是，在***宏定义中表达式的括号不能少***，否则会发生错误。得到的结果很可能不是自己想要的。

对于宏定义还要说明以下几点：

- 1）宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单的替换，字符串中可以有任何字符，可以是常数，也可以是表达式，预处理程序不对他作任何检查。如有错误，只能在编译已被宏展开后的源程序时发现。
- 2）宏定义不是说明或语句，在行末不必加分号，如加上分号，则连分号也一起置换。
- 3）宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可以使用 `#undef` 命令

```c
#define PI 3.14159
main() {
  ...
}
#undef PI  // 终止PI的作用域
```

- 4）宏名在源程序中若用 `双引号` 引起来，则预处理程序不对其做宏代换。

```c
#define OK 100
main() {
 printf("OK");
}
```

- 5）宏定义允许嵌套

```c
#define PI 3.1415926
#define S PI*y*y   // PI是已定义的宏名
```

- 6）习惯上宏名使用大写字母。但不是强制的。
- 7）可用宏定义表示数据类型，使书写方便。

```c
#define STU struct stu

STU body[5],*p;  // 预处理后为struct stu body[5],*p;

// 又如：
#define INTEGER int

INTEGER a,b;
```

用宏定义表示数据类型和用typedef定义数据说明符的区别：

宏定义只是简单的字符串代换，是在预处理完成的，而typedef 是在编译时处理的，他不是做简单的代换，而是对类型说明符重新命名。被命名的标识符具有类型定义说明的功能。

```c
#define PIN1 int *
typedef (int *) PIN2;
```

从形式上看这两者相似，但在实际使用中却不相同：
`PIN1 a,b;` 在宏代换后变成 `int *a,b;`  表示的结果是 a是指向整型的指针变量，而b是整型变量！
`PIN2 a,b;` 表示 a，b 都是指向整型的指针变量。

- 8）对“输出格式”作宏定义，可以减少书写麻烦。

```c
#define P printf
#define D "%d\n"
#define F "%f\n"
main() {
 int a=5,c=8,e=11;
 float b=3.8,d=9.7,f=21.08;
 P(D F,a,b);
 P(D F,c,d);
 P(D F,e,f);
}
```


---



## 2. 带参宏定义#define

```c
#define 宏名(形参表) 字符串
```

例如：

```c
#define M(y) y*y+3*y

k=M(5);   // 预处理后为k=y*y+3*y
```

对于带参的宏定义有以下问题需要说明：

- 1）带参宏定义中，宏名和形参表之间不能有空格出现。例如把
  `#define MAX(a,b) (a>b)?a:b`
  写为如下的格式(MAX后面多了一个空格),将被认为是 无参宏定义！！
  `#define MAX (a,b) (a>b)?a:b`
- 2）在带参宏定义中，形式参数不分配内存单元，因此不必做类型定义。
  而宏调用中的实参有具体的值。
  要用他们其代换形参，因此必须做类型说明。
  这是与函数中的情况不同的。
  在带参宏中，只是符号代换，不存在值传递的问题。
- 3）在宏定义中的形参是标识符，而宏调用中的实参可以是表达式，这与函数也是不同的，函数调用是先求表达式的值，但宏只是做字符串替换！不会去求表达式的值。
- 4）在宏定义中，字符串内的形参通常要用括号括起来以避免出错。例如：

```c
#define SQ(y) y*y

sq=SQ(a+1);  // 预处理后为a+1*a+1
```

代换字符串后是 `a+1*a+1` , 这显然不是你想要的结果

有时即使在参数两边加括号都不够，例如：

```c
#define SQ(y) (y)*(y)
main() {
 int a,sq;
 a=3;
 sq=160/SQ(a+1);   // 预处理后为160/(a+1)*(a+1)，正确的宏定义为#define SQ(y) ((y)*(y))
 printf("sq=%d\n",sq);
}
```

期望结果是 `160/16=10;` 但是实际结果却是 160，这是为什么？
 代换字符串后表达式为：`160/(a+1)*(a+1)` 这相当于 160 先除以 a+1，然后再乘以 a+1 ，当然结果是160
 这说明对于宏定义不仅应在参数两侧加括号，也应在整个字符串外加括号。如 `#define SQ(y) ((y)*(y))`

- 5）带参的宏和带参函数很相似，但有本质上的不同。时刻记住**宏是代换字符串**。如下面的例子：

```c
main() {
 i=1;
 while (i<=5)
  print("%d\n",SQ(i++));
}

// 定义带参函数
SQ(int y) {
  return ((y)*(y));
}
```

每循环一次i的值自增1
输出：
1 4 9 16 25

```bash
#define SQ(y) ((y)*(y))
main() {
 i=1;
 while (i<=5)
   print("%d\n",SQ(i++));  // 预处理后为print("%d\n",((i++)*(i++)));
}
```

每循环一次i的值自增2
输出：
2 12 30

- 6）宏定义也可用来定义多个语句，在宏调用时，把这些语句又代换到源程序内。

```c
#define SSSV(s1,s2,s3,v) s1=l*w;s2=l*h;s3=w*h;v=w*l*h;
```



---



## 3. 文件包含#include

文件包含命令的功能是把指定的文件插入该命令行位置取代该命令行，从而把指定的文件和当前的源程序文件练成一个源文件。

对文件包含命令要说明的几点：

- 1）`<>` 和 `""` 都是允许的，如 `#include"stdio.h"` `#include<stdio.h>` 都允许，但是两者是有区别的：
   使用 `尖括号` 表示在 `包含文件目录` 中去查找（ `包含目录` 是由用户在设置环境时设置的），而不在 `源文件目录` 去查找；
   使用 `双引号` 表示 首先在 `当前的源文件目录` 中查找，若未找到才到 `包含目录` 中去查找。用户编程时可根据自己文件所在的目录来选择某一种命令形式。
- 2）一个 `include指令` 只能指定一个被包含文件，若有多个文件要包含，则需用多个 `include指令` 。
- 3）文件包含允许嵌套，即在一个被包含的文件中又可以包含另一个文件。



---



## 4. 条件编译

有3种形式

### （1）第一种形式

```c
#ifdef 标识符
   程序段1
#else 
   程序段2
#endif
```

功能是，如果标识符已被 `#define指令` 定义过则对 `程序段1` 进行编译；否则对 `程序段2` 进行编译。
如果没有 `程序段2` ，本格式中的 `#else`可以没有，即可以写为：

```c
#ifdef 标识符
 程序段
#endif
```

例如：

```c
#define NUM ok
main() {
  ...
#ifdef NUM
  ...
#else
  ...
#endif
  ...
}
```

程序的第一行宏定义中，定义 NUM 的值可以为任何值，甚至不给出任何字符串。
写为 `#define NUM` 都可以。



### （2）第二种形式

```c
#ifndef 标识符
  程序段1
#else 
  程序段2
#endif
```

功能是，如果标识符没有被 `#define指令` 定义过则对 `程序段1` 进行编译；否则对 `程序段2` 进行编译。

起到的效果是防止一个源文件两次包含同一个头文件，而不是防止两个源文件包含同一个头文件。

**最佳实践：头文件的全部内容都放在#ifndef和#endif中，不管会不会被多个文件引用，最好是都这样做**

例如：

```c
#ifndef X   // 先测试是否被宏定义过
#define X   // 定义X
    程序段1  //如果X没有被宏定义过，定义X，并编译程序段1；
#else
    程序段2  //如果X已经定义过了则编译程序段2 的语句，忽视程序段1.
#endif
```



### （3）第三种形式

```c
#if 常量表达式
  程序段1
#else
  程序段2
#endif
```

他的功能是，如常量表达式的值为真（非0），则对程序段1进行编译，否则对程序段2进行编译。
因此可以在不同条件下，完成不同的功能。

例如：

```c
#define R 1
main() {
  ...
#if R  // 预处理后为 if 1  返回为true，对其后面程序1段进行编译
  ...  // 程序段1
#else
  ...  // 程序段2
#endif
  ...
}
```

虽然也可以用条件语句来实现，但是用条件语句将会对整个源程序进行编译，生成的目标代码程序很长，而采用条件编译，则根据条件只编译其中的 程序段1 或 程序段2 ，生成的目标程序较短。
如果条件选择的程序段很长，采用条件编译的方法是十分必要的。







